<?php
// from https://dev.to/agenceappy/generating-po-files-with-laravel-translating-blade-templates-15im
// By Agence Appy
namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\File;

class TranslationsParsePublicJSCommand extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'translations:parse-publicjs';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Parse scripts to find translations and insert it in javascript files';

    /**
     * The functions used in your scripts to translate strings
     *
     * @var string
     */
    protected $functions = ['singular' => ['__'], 'plural' => ['_n']];

    /**
     * Execute the console command.
     *
     * @return int
     */
    public function handle()
    {
        $dir = public_path('js');
       

        // Init translations global container
        echo "Exploring " . $dir . "\n";
        $translations = [];
        foreach ($this->functions['singular'] as $strFunction):
            $translations[$strFunction] = [];
        endforeach;
        foreach ($this->functions['plural'] as $strFunction):
            $translations[$strFunction] = [];
        endforeach;

        // Parse all files from folder
        $files = File::allFiles($dir);
        foreach ($files as $file):
            // Parse all lines from file
            echo "Parsing " . $file . "\n";
            $lines = File::lines($file);
            foreach ($lines as $index => $line):
                // Get strings from line
                $strings = $this->parseLine($line);

                // Insert strings into global translations container
                foreach ($this->functions as $type => $functions):
                    foreach ($functions as $strFunction):
                        if (!empty($strings[$strFunction])):

                            foreach ($strings[$strFunction] as $val):
                                if (is_array($val)) {
                                    $string = $val[0].','.$val[1];
                                } else {
                                    $string = $val;
                                }
                                if (isset($translations[$strFunction][$string])) {
                                    $translations[$strFunction][$string][] = $file->getPathname().':'.($index+1);
                                } else {
                                    $translations[$strFunction][$string] = [$file->getPathname().':'.($index+1)];
                                }
                            endforeach;

                        endif;
                    endforeach;
                endforeach;
            endforeach;
        endforeach;

        // Create directories if not exists
        $language_dir = lang_path('blade-translations');
        if (!File::isDirectory($language_dir)):
            File::makeDirectory($language_dir, 0755);
        endif;

        $path = explode('/', $dir);
        $interface = array_pop($path);
        $language_dir_interface = lang_path('blade-translations/'.$interface);
        echo $language_dir_interface;
        if (!File::isDirectory($language_dir_interface)):
            File::makeDirectory($language_dir_interface, 0755);
        endif;

        // Create file content
        $content = "<?php\n\n";
        $content .= "return [\n\n";
        $content .= "    /*\n";
        $content .= "    |--------------------------------------------------------------------------\n";
        $content .= "    | STATIC STRINGS TRANSLATIONS\n";
        $content .= "    |--------------------------------------------------------------------------\n";
        $content .= "    |\n";
        $content .= "    |  !!! WARNING - This is a file generated by the 'translations:parse-publicjs' command. !!!\n";
        $content .= "    |  You should not modify it, as it shall be replaced next time this command is executed.\n";
        $content .= "    |\n";
        $content .= "    */\n\n";

        $i = 0;
        foreach ($this->functions as $type => $functions):
            foreach ($functions as $strFunction):
                foreach ($translations[$strFunction] as $translation => $paths):
                    foreach ($paths as $p):
                        $content .= "    // $p \n";
                    endforeach;
                    $content .= "    $i => $strFunction($translation), \n";
                    $i++;
                endforeach;
            endforeach;
        endforeach;
        $content .= "\n];";

        // Generate file
        File::put($language_dir_interface.'/js.php', $content);
        $this->info('Strings have been exported from JS scripts successfully !');
    }

    /**
     * Return translated strings within the line
     */
    private function parseLine($line) {
        $return = [];

        // First let's see if the line has to be parsed
        $found = false;
        foreach ($this->functions as $type => $functions):
            foreach ($functions as $strFunction):
                $pos = strpos($line, $strFunction.'(');
                if ($pos !== false) {
                    $found = true;
                    break 2;
                }
            endforeach;
        endforeach;

        // if not, return
        if (!$found) return [];

        // Then parse for each function
        foreach ($this->functions as $type => $functions):
            foreach ($functions as $strFunction):
                $return[$strFunction] = [];
                $pos = strpos($line, $strFunction.'(');

                // if not found, head to next function
                if ($pos === false) continue;

                while ($pos !== false):
                    $arr = $this->getNextString($line, $pos, $type);
                    if (!$arr):
                        // Error findind string, leave loop
                        $pos = false;
                    else:
                        $line = $arr['line'];
                        $return[$strFunction][] = $arr['string'];
                        $pos = strpos($line, $strFunction.'(');
                    endif;
                endwhile;
            endforeach;
        endforeach;

        return $return;
    }

    /**
     * Return first string found and the rest of the line to be parsed
     */
    private function getNextString($subline, $pos, $type) {

        $substr = trim(substr($subline, $pos+3));

        $separator = $substr[0];
        $nextSeparatorPos = $this->getNextSeparator($substr, $separator);

        if (!$nextSeparatorPos) return [];

        if ($type == 'singular'):
            $string = substr($substr, 0, $nextSeparatorPos+1);
            $rest = substr($substr, $nextSeparatorPos+1);

            // security check : string must start and end with the separator => same character
            if ($string[0] != $string[strlen($string)-1]):
                return [];
            endif;

            return ['string' => $string, 'line' => $rest];
        else:
            $first_string = substr($substr, 0, $nextSeparatorPos+1);
            $rest = substr($substr, $nextSeparatorPos+1);

            // security check : string must start and end with the separator => same character
            if ($first_string[0] != $first_string[strlen($first_string)-1]):
                return [];
            endif;

            $comma_pos = strpos($rest, ',');
            $rest = trim(substr($rest, $comma_pos+1));

            $separator = $substr[0];
            $nextSeparatorPos = $this->getNextSeparator($rest, $separator);

            if (!$nextSeparatorPos) return [];

            $second_string = substr($rest, 0, $nextSeparatorPos+1);
            $rest = substr($rest, $nextSeparatorPos+1);

            // security check : string must start and end with the separator => same character
            if ($second_string[0] != $second_string[strlen($second_string)-1]):
                return [];
            endif;

            return ['string' => [$first_string, $second_string], 'line' => $rest];
        endif;
    }

    /**
     * Return first unescaped separator of string
     */
    private function getNextSeparator($str, $separator) {
        $substr = substr($str, 1);
        $found = false;
        preg_match_all('/'.$separator.'/', $substr, $matches, PREG_OFFSET_CAPTURE);
        foreach($matches[0] as $match):
            $pos = $match[1];
            if ($substr[$pos-1] != '\\'):
                $found = true;
                break;
            endif;
        endforeach;

        if ($found) return $pos+1;
        return false;
    }
}
